{"version":3,"sources":["usePaginatedChannels.ts"],"names":["wait","ms","Promise","resolve","setTimeout","DEFAULT_OPTIONS","message_limit","usePaginatedChannels","filters","options","sort","client","channels","setChannels","error","setError","hasNextPage","setHasNextPage","lastRefresh","Date","now","loadingChannels","setLoadingChannels","loadingNextPage","setLoadingNextPage","refreshing","setRefreshing","isMounted","queryChannels","queryType","retryCount","current","newOptions","limit","MAX_QUERY_CHANNELS_LIMIT","offset","length","channelQueryResponse","forEach","channel","state","setIsUpToDate","newChannels","console","warn","loadNextPage","undefined","refreshList","reloadList","filterStr","JSON","stringify","sortStr"],"mappings":"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","sourcesContent":["import { useEffect, useMemo, useRef, useState } from 'react';\n\nimport { MAX_QUERY_CHANNELS_LIMIT } from '../utils';\n\nimport { useChatContext } from '../../../contexts/chatContext/ChatContext';\nimport { useIsMountedRef } from '../../../hooks/useIsMountedRef';\n\nimport type { Channel, ChannelFilters, ChannelOptions, ChannelSort } from 'stream-chat';\n\nimport type {\n  DefaultAttachmentType,\n  DefaultChannelType,\n  DefaultCommandType,\n  DefaultEventType,\n  DefaultMessageType,\n  DefaultReactionType,\n  DefaultUserType,\n  UnknownType,\n} from '../../../types/types';\n\nconst wait = (ms: number) =>\n  new Promise((resolve) => {\n    setTimeout(resolve, ms);\n  });\n\ntype Parameters<\n  Ch extends UnknownType = DefaultChannelType,\n  Co extends string = DefaultCommandType,\n  Us extends UnknownType = DefaultUserType,\n> = {\n  filters: ChannelFilters<Ch, Co, Us>;\n  options: ChannelOptions;\n  sort: ChannelSort<Ch>;\n};\n\nconst DEFAULT_OPTIONS = {\n  message_limit: 10,\n};\n\nexport const usePaginatedChannels = <\n  At extends UnknownType = DefaultAttachmentType,\n  Ch extends UnknownType = DefaultChannelType,\n  Co extends string = DefaultCommandType,\n  Ev extends UnknownType = DefaultEventType,\n  Me extends UnknownType = DefaultMessageType,\n  Re extends UnknownType = DefaultReactionType,\n  Us extends UnknownType = DefaultUserType,\n>({\n  filters = {},\n  options = DEFAULT_OPTIONS,\n  sort = {},\n}: Parameters<Ch, Co, Us>) => {\n  const { client } = useChatContext<At, Ch, Co, Ev, Me, Re, Us>();\n\n  const [channels, setChannels] = useState<Channel<At, Ch, Co, Ev, Me, Re, Us>[]>([]);\n  const [error, setError] = useState(false);\n  const [hasNextPage, setHasNextPage] = useState(true);\n  const lastRefresh = useRef(Date.now());\n  const [loadingChannels, setLoadingChannels] = useState(false);\n  const [loadingNextPage, setLoadingNextPage] = useState(false);\n  const [refreshing, setRefreshing] = useState(false);\n  const isMounted = useIsMountedRef();\n\n  const queryChannels = async (queryType = '', retryCount = 0): Promise<void> => {\n    if (!client || loadingChannels || loadingNextPage || refreshing || !isMounted.current) return;\n\n    if (queryType === 'reload') {\n      setLoadingChannels(true);\n    } else if (queryType === 'refresh') {\n      setRefreshing(true);\n    } else if (!queryType) {\n      setLoadingNextPage(true);\n    }\n\n    const newOptions = {\n      limit: options?.limit ?? MAX_QUERY_CHANNELS_LIMIT,\n      offset: queryType === 'reload' || queryType === 'refresh' ? 0 : channels.length,\n      ...options,\n    };\n\n    try {\n      const channelQueryResponse = await client.queryChannels(filters, sort, newOptions);\n\n      if (!isMounted.current) return;\n\n      channelQueryResponse.forEach((channel) => channel.state.setIsUpToDate(true));\n\n      const newChannels =\n        queryType === 'reload' || queryType === 'refresh'\n          ? channelQueryResponse\n          : [...channels, ...channelQueryResponse];\n\n      setChannels(newChannels);\n      setHasNextPage(channelQueryResponse.length >= newOptions.limit);\n      setError(false);\n    } catch (err) {\n      await wait(2000);\n\n      if (!isMounted.current) return;\n\n      if (retryCount === 3) {\n        setLoadingChannels(false);\n        setLoadingNextPage(false);\n        setRefreshing(false);\n        console.warn(err);\n        return setError(true);\n      }\n\n      return queryChannels(queryType, retryCount + 1);\n    }\n\n    setLoadingChannels(false);\n    setLoadingNextPage(false);\n    setRefreshing(false);\n  };\n\n  const loadNextPage = hasNextPage ? queryChannels : undefined;\n  const refreshList = () => {\n    const now = Date.now();\n    // Only allow pull-to-refresh 5 seconds after last successful refresh.\n    if (now - lastRefresh.current < 5000 && !error) {\n      return;\n    }\n\n    lastRefresh.current = Date.now();\n    return queryChannels('refresh');\n  };\n  const reloadList = () => queryChannels('reload');\n\n  /**\n   * Equality check using stringified filters/sort ensure that we don't make un-necessary queryChannels api calls\n   * for the scenario:\n   *\n   * <ChannelList\n   *    filters={{\n   *      members: { $in: ['vishal'] }\n   *    }}\n   *    ...\n   * />\n   *\n   * Here we have passed filters as inline object, which means on every re-render of\n   * parent component, ChannelList will receive new object reference (even though value is same), which\n   * in return will trigger useEffect. To avoid this, we can add a value check.\n   */\n  const filterStr = useMemo(() => JSON.stringify(filters), [filters]);\n  const sortStr = useMemo(() => JSON.stringify(sort), [sort]);\n\n  useEffect(() => {\n    reloadList();\n  }, [filterStr, sortStr]);\n\n  return {\n    channels,\n    error,\n    hasNextPage,\n    loadingChannels,\n    loadingNextPage,\n    loadNextPage,\n    refreshing,\n    refreshList,\n    reloadList,\n    setChannels,\n  };\n};\n"]}