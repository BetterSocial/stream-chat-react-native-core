{"version":3,"sources":["useIsOnline.ts"],"names":["useIsOnline","client","closeConnectionOnBackground","isOnline","setIsOnline","connectionRecovering","setConnectionRecovering","isMounted","clientExits","onBackground","cid","activeChannels","channel","state","setIsUpToDate","closeConnection","onForeground","openConnection","handleChangedEvent","event","online","handleRecoveredEvent","notifyChatClient","netInfoState","wsConnection","onlineStatusChanged","type","unsubscribeNetInfo","setNetInfoListener","NetInfo","fetch","then","addEventListener","setInitialOnlineState","status","current","chatListeners","push","on","forEach","listener","unsubscribe"],"mappings":"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","sourcesContent":["import { useCallback, useEffect, useState } from 'react';\n\nimport { useAppStateListener } from '../../../hooks/useAppStateListener';\nimport { useIsMountedRef } from '../../../hooks/useIsMountedRef';\nimport { NetInfo } from '../../../native';\n\nimport type { NetInfoSubscription } from '@react-native-community/netinfo';\nimport type { StreamChat, Event as StreamEvent } from 'stream-chat';\n\nimport type {\n  DefaultAttachmentType,\n  DefaultChannelType,\n  DefaultCommandType,\n  DefaultEventType,\n  DefaultMessageType,\n  DefaultReactionType,\n  DefaultUserType,\n  UnknownType,\n} from '../../../types/types';\n\n/**\n * Disconnect the websocket connection when app goes to background,\n * and reconnect when app comes to foreground.\n * We do this to make sure, user receives push notifications when app is in the background.\n * You can't receive push notification until you have active websocket connection.\n */\nexport const useIsOnline = <\n  At extends UnknownType = DefaultAttachmentType,\n  Ch extends UnknownType = DefaultChannelType,\n  Co extends string = DefaultCommandType,\n  Ev extends UnknownType = DefaultEventType,\n  Me extends UnknownType = DefaultMessageType,\n  Re extends UnknownType = DefaultReactionType,\n  Us extends UnknownType = DefaultUserType,\n>(\n  client: StreamChat<At, Ch, Co, Ev, Me, Re, Us>,\n  closeConnectionOnBackground = true,\n) => {\n  const [isOnline, setIsOnline] = useState(true);\n  const [connectionRecovering, setConnectionRecovering] = useState(false);\n  const isMounted = useIsMountedRef();\n  const clientExits = !!client;\n\n  const onBackground = useCallback(() => {\n    if (!closeConnectionOnBackground) return;\n\n    for (const cid in client.activeChannels) {\n      const channel = client.activeChannels[cid];\n      channel?.state.setIsUpToDate(false);\n    }\n\n    client.closeConnection();\n    setIsOnline(false);\n  }, [closeConnectionOnBackground, client]);\n\n  const onForeground = useCallback(() => {\n    if (!closeConnectionOnBackground) return;\n\n    client.openConnection();\n  }, [closeConnectionOnBackground, client]);\n\n  useAppStateListener(onForeground, onBackground);\n\n  useEffect(() => {\n    const handleChangedEvent = (event: StreamEvent<At, Ch, Co, Ev, Me, Re, Us>) => {\n      setConnectionRecovering(!event.online);\n      setIsOnline(event.online || false);\n    };\n\n    const handleRecoveredEvent = () => setConnectionRecovering(false);\n\n    const notifyChatClient = (netInfoState: boolean) => {\n      if (client?.wsConnection) {\n        if (netInfoState) {\n          client.wsConnection.onlineStatusChanged({\n            type: 'online',\n          } as Event);\n        } else {\n          client.wsConnection.onlineStatusChanged({\n            type: 'offline',\n          } as Event);\n        }\n      }\n    };\n\n    let unsubscribeNetInfo: NetInfoSubscription;\n    const setNetInfoListener = () => {\n      NetInfo.fetch().then((netInfoState) => {\n        notifyChatClient(netInfoState);\n      });\n      unsubscribeNetInfo = NetInfo.addEventListener((netInfoState) => {\n        notifyChatClient(netInfoState);\n      });\n    };\n\n    const setInitialOnlineState = async () => {\n      const status = await NetInfo.fetch();\n\n      if (isMounted.current) setIsOnline(status);\n    };\n\n    setInitialOnlineState();\n    const chatListeners: Array<ReturnType<StreamChat['on']>> = [];\n\n    if (client) {\n      chatListeners.push(client.on('connection.changed', handleChangedEvent));\n      chatListeners.push(client.on('connection.recovered', handleRecoveredEvent));\n      setNetInfoListener();\n    }\n\n    return () => {\n      chatListeners.forEach((listener) => listener.unsubscribe?.());\n      unsubscribeNetInfo?.();\n    };\n  }, [clientExits]);\n\n  return { connectionRecovering, isOnline };\n};\n"]}